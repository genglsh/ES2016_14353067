# 					死锁

## 1. 死锁停止的截图：

​                                                ![  img](http://p1.bpimg.com/567571/3c3e8837adf36dde.png)

## 2. 形成死锁的四个条件：

#### 	资源互斥：一个资源在同一个时间仅能被一个线程使用

#### 	不可剥夺：线程拥有的资源不能被强行剥夺

#### 	循环等待：若干进程之间形成一种头尾相接的循环等待资源关系

#### 	请求与保持：线程被因请求资源等待的时候不会释放已经拥有的资源

## 3. 上述过程产生死锁的原因分析：

#### 	我们应该很明确的知道cpu的运行方式是轮转法，所以for循环调用Deadlock的过程中，主线程先开始运行，然后主线程创建子线程t，并将线程t加入到就绪队列当中去，然后主线程通过while循环进入忙等待状态，在这个期间时间片会给两个线程轮流使用，当线程t拿到时间片运行的时候就会调用methodB（类似于拿到了lockB），然后该方法又会调用a.last(类似于请求lockA),而对于主线程来说while忙等待之后就会执行methodA（拿到lockA），然后该方法又请求b.last（请求lockB），因为时间片有限cpu执行的不确定性就会造成一个循环等待的情况：线程t占有b请求a，主线程占有a请求b。

